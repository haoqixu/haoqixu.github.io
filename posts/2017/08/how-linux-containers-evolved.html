
<!DOCTYPE html>
<html lang="zh">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://blog.xu0o0.me/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://blog.xu0o0.me/theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="http://blog.xu0o0.me/theme/font-awesome/css/font-awesome.min.css">


    <link href="http://blog.xu0o0.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="~xu0o0 Atom">



  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />


<meta name="author" content="xu0o0" />
<meta name="description" content="原文链接：https://opensource.com/article/17/7/how-linux-containers-evolved 原文作者：Daniel J Walsh 校对：Linux.CN 的 wxy 前辈 发布平台：Linux中国 Linux 容器是如何演变的 在过去几年内，容器不仅成为了开发者们热议的话题，还受到了企业的关注。持续增长的关注使得在它的安全性、可扩展性以及互用性等方面的需求也得以增长。满足这些需求需要很大的工程量，下面我们讲讲在红帽这样的企业级这些工程是如何发展的。 我在 2013 年秋季第一次遇到 Docker 公司（Docker.io）的代表，那时我们在设法使 Red Hat Enterprise Linux (RHEL) 支持 Docker 容器（现在 Docker 项目的一部分已经更名为 Moby …" />
<meta name="keywords" content="container, docker, linux, 翻译">
<meta property="og:site_name" content="~xu0o0"/>
<meta property="og:title" content="【译】Linux 容器演化史"/>
<meta property="og:description" content="原文链接：https://opensource.com/article/17/7/how-linux-containers-evolved 原文作者：Daniel J Walsh 校对：Linux.CN 的 wxy 前辈 发布平台：Linux中国 Linux 容器是如何演变的 在过去几年内，容器不仅成为了开发者们热议的话题，还受到了企业的关注。持续增长的关注使得在它的安全性、可扩展性以及互用性等方面的需求也得以增长。满足这些需求需要很大的工程量，下面我们讲讲在红帽这样的企业级这些工程是如何发展的。 我在 2013 年秋季第一次遇到 Docker 公司（Docker.io）的代表，那时我们在设法使 Red Hat Enterprise Linux (RHEL) 支持 Docker 容器（现在 Docker 项目的一部分已经更名为 Moby …"/>
<meta property="og:locale" content="zh_CN"/>
<meta property="og:url" content="http://blog.xu0o0.me/posts/2017/08/how-linux-containers-evolved.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-08-29 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://blog.xu0o0.me/author/xu0o0.html">
<meta property="article:section" content="Tech"/>
<meta property="article:tag" content="container"/>
<meta property="article:tag" content="docker"/>
<meta property="article:tag" content="linux"/>
<meta property="article:tag" content="翻译"/>
<meta property="og:image" content="/img/avatar.jpg">

  <title>~xu0o0 &ndash; 【译】Linux 容器演化史</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://blog.xu0o0.me">
        <img src="/img/avatar.jpg" alt="~xu0o0" title="~xu0o0">
      </a>
      <h1><a href="http://blog.xu0o0.me">~xu0o0</a></h1>


      <nav>
        <ul class="list">
          <li><a href="http://blog.xu0o0.me/pages/About.html#About">About</a></li>
          <li><a href="http://blog.xu0o0.me/pages/Blogroll.html#Blogroll">Blogroll</a></li>

        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github" href="https://github.com/haoqixu" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-envelope-o" href="mailto:hqcat6@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://blog.xu0o0.me">    Home
</a>

      <a href="/archives.html">archives</a>
      <a href="/categories.html">categories</a>
      <a href="/tags.html">tags</a>

      <a href="http://blog.xu0o0.me/feeds/all.atom.xml">    Atom
</a>

    </nav>

<article class="single">
  <header>
    <h1 id="how-linux-containers-evolved">【译】Linux 容器演化史</h1>
    <p>
          Posted on 2017年08月29日(周二) in <a href="http://blog.xu0o0.me/category/tech.html">Tech</a>


    </p>
  </header>
  <div>
    <blockquote>
<p>原文链接：<a href="https://opensource.com/article/17/7/how-linux-containers-evolved">https://opensource.com/article/17/7/how-linux-containers-evolved</a></p>
<p>原文作者：<a href="https://opensource.com/users/rhatdan">Daniel J Walsh</a></p>
<p>校对：<a href="https://linux.cn/article-8811-1.html">Linux.CN</a> 的 <a href="https://github.com/wxy">wxy 前辈</a></p>
<p>发布平台：<a href="https://linux.cn/article-8811-1.html">Linux中国</a></p>
</blockquote>
<p><img alt="How Linux containers have evolved" src="https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/containers_2015-3-osdc-lead.png?itok=O6aivM_W" title="Linux 容器的演化过程" /></p>
<h3 id="linux">Linux 容器是如何演变的</h3>
<p>在过去几年内，容器不仅成为了开发者们热议的话题，还受到了企业的关注。持续增长的关注使得在它的安全性、可扩展性以及互用性等方面的需求也得以增长。满足这些需求需要很大的工程量，下面我们讲讲在红帽这样的企业级这些工程是如何发展的。</p>
<p>我在 2013 年秋季第一次遇到 Docker 公司（Docker.io）的代表，那时我们在设法使 Red Hat Enterprise Linux (RHEL) 支持 Docker 容器（现在 Docker 项目的一部分已经更名为 <em>Moby</em>）的运行。在移植过程中，我们遇到了一些问题。处理容器镜像分层所需的写时拷贝（COW）文件系统成了我们第一个重大阻碍。Red Hat 最终贡献了一些 COW 文件系统实现，包括 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Logical_Volume_Manager_Administration/device_mapper.html">Device Mapper</a>、<a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">btrf</a>，以及 <a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt">OverlayFS</a> 的第一个版本。在 RHEL 上，我们默认使用 Device Mapper， 但是我们在 OverlayFS 上也已经取得了很大进展。</p>
<p>我们在用于启动容器的工具上遇到了第二个主要障碍。那时的上游 docker 使用 <a href="https://linuxcontainers.org/">LXC</a> 工具来启动容器，然而我们不想在 RHEL 上支持 LXC 工具集。而且在与上游 docker 合作之前，我们已经与 <a href="https://libvirt.org/">libvrit</a> 团队携手构建了 <a href="http://sandbox.libvirt.org/">virt-sandbox</a> 工具，它使用 <code>libvrit-lxc</code> 来启动容器。</p>
<p>在那时，红帽里有员工提到一个好办法，换掉 LXC 工具集而添加桥接器，以便 docker 守护进程通过 <code>libvirt-lxc</code> 与 libvirt 通讯来启动容器。这个方案也有一些顾虑。考虑下面这个例子，使用 Docker 客户端（<code>docker-cli</code>）来启动容器，各层调用会在容器进程（<code>pid1OfContainer</code>）之前依次启动：</p>
<blockquote>
<p><strong>docker-cli → docker-daemon → libvirt-lxc → pid1OfContainer</strong></p>
</blockquote>
<p>我不是很喜欢这个方案，因为它在启动容器的工具与最终的容器进程之间有两个守护进程。</p>
<p>我的团队与上游 docker 开发者合作实现了一个原生的 <a href="https://opensource.com/article/17/6/getting-started-go">Go 编程语言</a> 版本的容器运行时，叫作 <a href="https://github.com/opencontainers/runc/tree/master/libcontainer">libcontainer</a>。这个库作为 [OCI 运行时规范]的最初版实现与 runc 一同发布。</p>
<blockquote>
<p><strong>docker-cli → docker-daemon @ pid1OfContainer</strong></p>
</blockquote>
<p>大多数人误认为当他们执行一个容器时，容器进程是作为 <code>docker-cli</code> 的子进程运行的。实际上他们执行的是一个客户端/服务端请求操作，容器进程是在一个完全单独的环境作为子进程运行的。这个客户端/服务端请求会导致不稳定性和潜在的安全问题，而且会阻碍一些实用特性的实现。举个例子，<a href="https://opensource.com/business/15/10/lisa15-interview-alison-chaiken-mentor-graphics">systemd</a> 有个叫做套接字唤醒的特性，你可以将一个守护进程设置成仅当相应的套结字被连接时才启动。这意味着你的系统可以节约内存并按需执行服务。套结字唤醒的工作原理是 systemd 代为监听 TCP 套结字，并在数据包到达套结字时启动相应的服务。一旦服务启动完毕，systemd 将套结字交给新启动的守护进程。如果将守护进程运行在基于 docker 的容器中就会出现问题。systemd 的 unit 文件通过 Docker CLI 执行容器，然而这时 systemd 却无法简单地经由 Docker CLI 将套结字转交给 Docker 守护进程。</p>
<p>类似这样的问题让我们意识到我们需要一个运行容器的替代方案。</p>
<h4 id="_1">容器编排问题</h4>
<p>上游的 docker 项目简化了容器的使用过程，同时也是一个绝佳的 Linux 容器学习工具。你可以通过一条简单的命令快速地体验如何启动一个容器，例如运行 <code>docker run -ti fedora sh</code> 然后你就立即处于一个容器之中。</p>
<p>当开始把许多容器组织成一个功能更为强大的应用时，你才能体会到容器真正的能力。但是问题在于伴随多容器应用而来的高复杂度使得简单的 Docker 命令无法胜任编排工作。你要如何管理容器应用在有限资源的集群节点间的布局与编排？如何管理它们的生命周期等等？</p>
<p>在第一届 DockerCon，至少有 7 种不同的公司/开源项目展示了其容器的编排方案。红帽演示了 <a href="https://www.openshift.com/">OpenShift</a> 的 <a href="https://openshift.github.io/geard/">geard</a> 项目，它基于 OpenShift v2 的容器（叫作 gears）。红帽觉得我们需要重新审视容器编排，而且可能要与开源社区的其他人合作。</p>
<p>Google 则演示了 Kubernetes 容器编排工具，它来源于 Google 对其自内部架构进行编排时所积累的知识经验。OpenShift 决定放弃 Gear 项目，开始和 Google 一同开发 Kubernetes。 现在 Kubernetes 是 GitHub 上最大的社区项目之一。</p>
<h4 id="kubernetes">Kubernetes</h4>
<p>Kubernetes 原先被设计成使用 Google 的 <a href="https://github.com/google/lmctfy">lmctfy</a> 容器运行时环境来完成工作。在 2014 年夏天，lmctfy 兼容了 docker。Kubernetes 还会在 kubernetes 集群的每个节点运行一个 <a href="https://kubernetes.io/docs/admin/kubelet/">kubelet</a> 守护进程，这意味着原先使用 docker 1.8 的 kubernetes 工作流看起来是这样的：</p>
<blockquote>
<p><strong>kubelet → dockerdaemon @ PID1</strong></p>
</blockquote>
<p>回退到了双守护进程的模式。</p>
<p>然而更糟糕的是，每次 docker 的新版本发布都使得 kubernetes 无法工作。Docker 1.10 切换镜像底层存储方案导致所有镜像重建。而 Docker 1.11 开始使用 <code>runc</code> 来启动镜像：</p>
<blockquote>
<p><strong>kubelet → dockerdaemon @ runc @PID1</strong></p>
</blockquote>
<p>Docker 1.12 则增加了一个容器守护进程用于启动容器。其主要目的是为了支持 Docker Swarm （Kubernetes 的竞争者之一）：</p>
<blockquote>
<p><strong>kubelet → dockerdaemon → containerd @runc @ pid1</strong></p>
</blockquote>
<p>如上所述，<em>每一次</em> docker 发布都破坏了 Kubernetes 的功能，这也是为什么 Kubernetes 和 OpenShift 请求我们为他们提供老版本 Docker 的原因。</p>
<p>现在我们有了一个三守护进程的系统，只要任何一个出现问题，整个系统都将崩溃。</p>
<h3 id="_2">走向容器标准化</h3>
<h4 id="coreosrkt">CoreOS、rkt 和其它替代运行时</h4>
<p>因为 docker 运行时带来的问题，几个组织都在寻求一个替代的运行时。CoreOS 就是其中之一。他们提供了一个 docker 容器运行时的替代品，叫 <em>rkt</em> （rocket）。他们同时还引入一个标准容器规范，称作 <em>appc</em> （App Container）。从根本上讲，他们是希望能使得所有人都使用一个标准规范来管理容器镜像中的应用。</p>
<p>这一行为为标准化工作树立了一面旗帜。当我第一次开始和上游 docker 合作时，我最大的担忧就是最终我们会分裂出多个标准。我不希望类似 RPM 和 DEB 之间的战争影响接下来 20 年的 Linux 软件部署。appc 的一个成果是它说服了上游 docker 与开源社区合作创建了一个称作 <a href="https://www.opencontainers.org/">开放容器计划（Open Container Initiative）</a> (OCI) 的标准团体。</p>
<p>OCI 已经着手制定两个规范：</p>
<p><a href="https://github.com/opencontainers/runtime-spec/blob/master/spec.md">OCI 运行时规范</a>：OCI 运行时规范“旨在规范容器的配置、执行环境以及生命周期”。它定义了容器的磁盘存储，描述容器内运行的应用的 JSON 文件，容器的生成和执行方式。上游 docker 贡献了 libcontainer 并构建了 runc 作为 OCI 运行时规范的默认实现。</p>
<p><a href="https://github.com/opencontainers/image-spec/blob/master/spec.md">OCI 镜像文件格式规范</a>：镜像文件格式规范主要基于上游 docker 所使用的镜像格式，定义了容器仓库中实际存储的容器镜像格式。该规范使得应用开发者能为应用使用单一的标准化格式。一些 appc 中描述的概念被加入到 OCI 镜像格式规范中得以保留。这两份规范 1.0 版本的发布已经临近（LCTT 译注：<a href="https://linux.cn/article-8778-1.html">已经发布</a>）。上游 docker 已经同意在 OCI 镜像规范定案后支持该规范。Rkt 现在既支持运行 OCI 镜像也支持传统的上游 docker 镜像。</p>
<p>OCI 通过为工业界提供容器镜像与运行时标准化的环境，帮助在工具与编排领域解放创新的力量。</p>
<h4 id="_3">抽象运行时接口</h4>
<p>得益于标准化工作， Kubernetes 编排领域也有所创新。作为 Kubernetes 的一大支持者，CoreOS 提交了一堆补丁，使 Kubernetes 除了 docker 引擎外还能通过 rkt 运行容器并且与容器通讯。Google 和 Kubernetes 上游预见到增加这些补丁和将来可能添加的容器运行时接口将给 Kubernetes 带来的代码复杂度，他们决定实现一个叫作 容器运行时接口（Container Runtime Interface） (CRI) 的 API 协议规范。于是他们将 Kubernetes 由原来的直接调用 docker 引擎改为调用 CRI，这样任何人都可以通过实现服务器端的 CRI 来创建支持
Kubernetes 的容器运行时。Kubernetes 上游还为 CRI 开发者们创建了一个大型测试集以验证他们的运行时对 Kubernetes 的支持情况。开发者们还在努力地移除 Kubernetes 对 docker 引擎的调用并将它们隐藏在一个叫作 docker-shim 的薄抽象层后。</p>
<h3 id="_4">容器工具的创新</h3>
<h4 id="skopeo">伴随 skopeo 而来的容器仓库创新</h4>
<p>几年前我们正与 Atomic 项目团队合作构建 <a href="https://github.com/projectatomic/atomic">atomic CLI</a>。我们希望实现一个功能，在镜像还在镜像仓库时查看它的细节。在那时，查看仓库中的容器镜像相关 JSON 文件的唯一方法是将镜像拉取到本地服务器再通过 <code>docker inspect</code> 来查看 JSON 文件。这些镜像可能会很大，上至几个 GiB。为了允许用户在不拉取镜像的情况下查看镜像细节，我们希望在 <code>docker inspect</code> 接口添加新的 <code>--remote</code> 参数。上游 docker 拒绝了我们的代码拉取请求（PR），告知我们他们不希望将 Docker CLI 复杂化，我们可以构建我们自己的工具去实现相同的功能。</p>
<p>我们的团队在 <a href="https://twitter.com/runc0m">Antonio Murdaca</a> 的领导下执行这个提议，构建了 <a href="https://github.com/projectatomic/skopeo">skopeo</a>。Antonio 没有止步于拉取镜像相关的 JSON 文件，而是决定实现一个完整的协议，用于在容器仓库与本地主机之间拉取与推送容器镜像。</p>
<p>skopeo 现在被 atomic CLI 大量用于类似检查容器更新的功能以及 <a href="https://developers.redhat.com/blog/2016/05/02/introducing-atomic-scan-container-vulnerability-detection/">atomic 扫描</a> 当中。Atomic 也使用 skopeo 取代上游 docker 守护进程拉取和推送镜像的功能。</p>
<h4 id="containersimage">Containers/image</h4>
<p>我们也曾和 CoreOS 讨论过在 rkt 中使用 skopeo 的可能，然而他们表示不希望运行一个外部的协助程序，但是会考虑使用 skopeo 所使用的代码库。于是我们决定将 skopeo 分离为一个代码库和一个可执行程序，创建了 <a href="https://github.com/containers/image">image</a> 代码库。</p>
<p><a href="https://github.com/containers/image">containers/images</a> 代码库和 skopeo 被几个其它上游项目和云基础设施工具所使用。Skopeo 和 containers/image 已经支持 docker 和多个存储后端，而且能够在容器仓库之间移动容器镜像，还拥有许多酷炫的特性。<a href="http://rhelblog.redhat.com/2017/05/11/skopeo-copy-to-the-rescue/">skopeo 的一个优点</a>是它不需要任何守护进程的协助来完成任务。Containers/image 代码库的诞生使得类似<a href="https://access.redhat.com/articles/2750891">容器镜像签名</a>等增强功能得以实现。</p>
<h4 id="_5">镜像处理与扫描的创新</h4>
<p>我在前文提到 atomic CLI。我们构建这个工具是为了给容器添加不适合 docker CLI 或者我们无法在上游 docker 中实现的特性。我们也希望获得足够灵活性，将其用于开发额外的容器运行时、工具和存储系统。Skopeo 就是一例。</p>
<p>我们想要在 atomic 实现的一个功能是 <code>atomic mount</code>。从根本上讲，我们希望从 Docker 镜像存储（上游 docker 称之为 graph driver）中获取内容，把镜像挂在到某处，以便用工具来查看该镜像。如果你使用上游的 docker，查看镜像内容的唯一方法就是启动该容器。如果其中有不可信的内容，执行容器中的代码来查看它会有潜在危险。通过启动容器查看镜像内容的另一个问题是所需的工具可能没有被包含在容器镜像当中。</p>
<p>大多数容器镜像扫描器遵循以下流程：它们连接到 Docker 的套结字，执行一个 <code>docker save</code> 来创建一个 tar 打包文件，然后在磁盘上分解这个打包文件，最后查看其中的内容。这是一个很慢的过程。</p>
<p>通过 <code>atomic mount</code>，我们希望直接使用 Docker graph driver 挂载镜像。如果 docker 守护进程使用 device mapper，我们将挂载这个设备。如果它使用 overlay，我们会挂载 overlay。这个操作很快而且满足我们的需求。现在你可以执行：</p>
<div class="highlight"><pre><span></span># atomic mount fedora /mnt
# cd /mnt
</pre></div>


<p>然后开始探查内容。你完成相应工作后，执行：</p>
<div class="highlight"><pre><span></span># atomic umount /mnt
</pre></div>


<p>我们在 <code>atomic scan</code> 中使用了这一特性，实现了一个快速的容器扫描器。</p>
<h4 id="_6">工具协作的问题</h4>
<p>其中一个严重的问题是 <code>atomic mount</code> 隐式地执行这些工作。Docker 守护进程不知道有另一个进程在使用这个镜像。这会导致一些问题（例如，如果你先挂载了 Fedora 镜像，然后某个人执行了 <code>docker rmi fedora</code> 命令，docker 守护进程移除镜像时就会产生奇怪的操作失败，同时报告说相应的资源忙碌）。Docker 守护进程可能因此进入一个奇怪的状态。</p>
<h4 id="_7">容器存储系统</h4>
<p>为了解决这个问题，我们开始尝试将从上游 docker 守护进程剥离出来的 graph driver 代码拉取到我们的代码库中。Docker 守护进程在内存中为 graph driver 完成所有锁的获取。我们想要将这些锁操作转移到文件系统中，这样我们可以支持多个不同的进程来同时操作容器的存储系统，而不用通过单一的守护进程。</p>
<p>我们创建了 <a href="https://github.com/containers/storage">containers/storage</a> 项目，实现了容器运行、构建、存储所需的所有写时拷贝（COW）特性，同时不再需要一个单一进程来控制和监控这个过程（也就是不需要守护进程）。现在 skopeo 以及其它工具和项目可以直接利用镜像的存储系统。其它开源项目也开始使用 containers/storage，在某些时候，我们也会把这些项目合并回上游 docker 项目。</p>
<h3 id="_8">驶向创新</h3>
<p>当 Kubernetes 在一个节点上使用 docker 守护进程运行容器时会发生什么？首先，Kubernetes 执行一条类似如下的命令：</p>
<div class="highlight"><pre><span></span>kubelet run nginx -image=nginx
</pre></div>


<p>这个命令告诉 kubelet 在节点上运行 NGINX 应用程序。kubelet 调用 CRI 请求启动 NGINX 应用程序。在这时，实现了 CRI 规范的容器运行时必须执行以下步骤：</p>
<ol>
<li>检查本地是否存在名为 <code>nginx</code> 的容器。如果没有，容器运行时会在容器仓库中搜索标准的容器镜像。</li>
<li>如果镜像不存在于本地，从容器仓库下载到本地系统。</li>
<li>使用容器存储系统（通常是写时拷贝存储系统）解析下载的容器镜像并挂载它。</li>
<li>使用标准的容器运行时执行容器。</li>
</ol>
<p>让我们看看上述过程使用到的特性：</p>
<ol>
<li>OCI 镜像格式规范定义了容器仓库存储的标准镜像格式。</li>
<li>Containers/image 代码库实现了从容器仓库拉取镜像到容器主机所需的所有特性。</li>
<li>Containers/storage 提供了在写时拷贝的存储系统上探查并处理 OCI 镜像格式的代码库。</li>
<li>OCI 运行时规范以及 <code>runc</code> 提供了执行容器的工具（同时也是 docker 守护进程用来运行容器的工具）。</li>
</ol>
<p>这意味着我们可以利用这些工具来使用容器，而无需一个大型的容器守护进程。</p>
<p>在中等到大规模的基于 DevOps 的持续集成/持续交付环境下，效率、速度和安全性至关重要。只要你的工具遵循 OCI 规范，开发者和执行者就能在持续集成、持续交付到生产环境的自动化中自然地使用最佳的工具。大多数的容器工具被隐藏在容器编排或上层容器平台技术之下。我们预想着有朝一日，运行时和镜像工具的选择会变成容器平台的一个安装选项。</p>
<h4 id="_9">系统（独立）容器</h4>
<p>在 Atomic 项目中我们引入了<ruby>原子主机<rt>atomic host</rt></ruby>，一种新的操作系统构建方式：所有的软件可以被“原子地”升级并且大多数应用以容器的形式运行在操作系统中。这个平台的目的是证明将来所有的软件都能部署在 OCI 镜像格式中并且使用标准协议从容器仓库中拉取，然后安装到系统上。用容器镜像的形式发布软件允许你以不同的速度升级应用程序和操作系统。传统的 RPM/yum/DNF 包分发方式把应用更新锁定在操作系统的生命周期中。</p>
<p>在以容器部署基础设施时多数会遇到一个问题——有时一些应用必须在容器运行时执行之前启动。我们看一个使用 docker 的 Kubernetes 的例子：Kubernetes 为了将 pods 或者容器部署在独立的网络中，要求先建立一个网络。现在默认用于创建网络的守护进程是 <a href="https://github.com/coreos/flannel">flanneld</a>，而它必须在 docker 守护进程之前启动，以支持 docker 网络接口来运行 Kubernetes 的 pods。而且，flanneld 使用 <a href="https://github.com/coreos/etcd">etcd</a> 来存储数据，这个守护进程必须在 flanneld 启动之前运行。</p>
<p>如果你想把 etcd 和 flanneld 部署到容器镜像中，那就陷入了鸡与鸡蛋的困境中。我们需要容器运行时来启动容器化的应用，但这些应用又需要在容器运行时之前启动。我见过几个取巧的方法尝试解决这个问题，但这些方法都不太干净利落。而且 docker 守护进程当前没有合适的方法来配置容器启动的优先级顺序。我见过一些提议，但它们看起来和 SysVInit 所使用的启动服务的方式相似（我们知道它带来的复杂度）。</p>
<h4 id="systemd">systemd</h4>
<p>用 systemd 替代 SysVInit 的原因之一就是为了处理服务启动的优先级和顺序，我们为什么不充分利用这种技术呢？在 Atomic 项目中我们决定在让它在没有容器运行时的情况下也能启动容器，尤其是在系统启动早期。我们增强了 atomic CLI 的功能，让用户可以安装容器镜像。当你执行 <code>atomic install --system etc</code>，它将利用 skopeo 从外部的容器仓库拉取 etcd 的 OCI 镜像，然后把它分解（扩展）为 OSTree 底层存储。因为 etcd 运行在生产环境中，我们把镜像处理为只读。接着 <code>atomic</code> 命令抓取容器镜像中的 systemd 的 unit 文件模板，用它在磁盘上创建 unit 文件来启动镜像。这个 unit 文件实际上使用 <code>runc</code> 来在主机上启动容器（虽然 <code>runc</code> 不是必需的）。</p>
<p>执行 <code>atomic install --system flanneld</code> 时会进行相似的过程，但是这时 flanneld 的 unit 文件中会指明它依赖 etcd。</p>
<p>在系统引导时，systemd 会保证 etcd 先于 flanneld 运行，并且直到 flanneld 启动完毕后再启动容器运行时。这样我们就能把 docker 守护进程和 Kubernetes 部署到系统容器当中。这也意味着你可以启动一台原子主机或者使用传统的基于 rpm 的操作系统，让整个容器编排工具栈运行在容器中。这是一个强大的特性，因为用户往往希望改动容器主机时不受这些组件影响。而且，它保持了主机的操作系统的占用最小化。</p>
<p>大家甚至讨论把传统的应用程序部署到独立/系统容器或者被编排的容器中。设想一下，可以用 <code>atomic install --system httpd</code> 命令安装一个 Apache 容器，这个容器可以和用 RPM 安装的 httpd 服务以相同的方式启动（<code>systemctl start httpd</code> ，区别是这个容器 httpd 运行在一个容器中）。存储系统可以是本地的，换言之，<code>/var/www</code> 是从宿主机挂载到容器当中的，而容器监听着本地网络的 80 端口。这表明了我们可以在不使用容器守护进程的情况下将传统的负载组件部署到一个容器中。</p>
<h3 id="_10">构建容器镜像</h3>
<p>在我看来，在过去 4 年来容器发展方面最让人失落的是缺少容器镜像构建机制上的创新。容器镜像不过是将一些 tar 包文件与 JSON 文件一起打包形成的文件。基础镜像则是一个 rootfs 与一个描述该基础镜像的 JSON 文件。然后当你增加镜像层时，层与层之间的差异会被打包，同时 JSON 文件会做出相应修改。这些镜像层与基础文件一起被打包，共同构成一个容器镜像。</p>
<p>现在几乎所有人都使用 <code>docker build</code> 与 Dockerfile 格式来构建镜像。上游 docker 已经在几年前停止了接受修改或改进 Dockerfile 格式的拉取请求（PR）了。Dockerfile 在容器的演进过程中扮演了重要角色，开发者和管理员/运维人员可以通过简单直接的方式来构建镜像；然而我觉得 Dockerfile 就像一个简陋的 bash 脚本，还带来了一些尚未解决的问题，例如：</p>
<ul>
<li>使用 Dockerfile 创建容器镜像要求运行着 Docker 守护进程。<ul>
<li>没有可以独立于 docker 命令的标准工具用于创建 OCI 镜像。</li>
<li>甚至类似 <code>ansible-containers</code> 和 OpenShift S2I (Source2Image) 的工具也在底层使用 <code>docker-engine</code>。</li>
</ul>
</li>
<li>Dockerfile 中的每一行都会创建一个新的镜像，这有助于创建容器的开发过程，这是因为构建工具能够识别 Dockerfile 中的未改动行，复用已经存在的镜像从而避免了未改动行的重复执行。但这个特性会产生_大量_的镜像层。<ul>
<li>因此，不少人希望构建机制能压制镜像消除这些镜像层。我猜想上游 docker 最后应该接受了一些提交满足了这个需求。</li>
</ul>
</li>
<li>要从受保护的站点拉取内容到容器镜像，你往往需要某种密钥。比如你为了添加 RHEL 的内容到镜像中，就需要访问 RHEL 的证书和订阅。<ul>
<li>这些密钥最终会被以层的方式保存在镜像中。开发者要费很大工夫去移除它们。</li>
<li>为了允许在 docker 构建过程中挂载数据卷，我们在我们维护的 projectatomic/docker 中加入了 <code>-v volume</code> 选项，但是这些修改没有被上游 docker 接受。</li>
</ul>
</li>
<li>构建过程的中间产物最终会保留在容器镜像中，所以尽管 Dockerfile 易于学习，当你想要了解你要构建的镜像时甚至可以在笔记本上构建容器，但它在大规模企业环境下还不够高效。然而在自动化容器平台下，你应该不会关心用于构建 OCI 镜像的方式是否高效。</li>
</ul>
<h3 id="buildah">Buildah 起航</h3>
<p>在 DevConf.cz 2017，我让我们团队的 <a href="https://twitter.com/nalind">Nalin Dahyabhai</a> 考虑构建被我称为 <code>containers-coreutils</code> 的工具，它基本上就是基于 containers/storage 和 containers/image 库构建的一系列可以使用类似 Dockerfile 语法的命令行工具。Nalin 为了取笑我的波士顿口音，决定把它叫做 <a href="https://github.com/projectatomic/buildah">buildah</a>。我们只需要少量的 buildah 原语就可以构建一个容器镜像：</p>
<ul>
<li>最小化 OS 镜像、消除不必要的工具是主要的安全原则之一。因为黑客在攻击应用时需要一些工具，如果类似 <code>gcc</code>，<code>make</code>，<code>dnf</code> 这样的工具根本不存在，就能阻碍攻击者的行动。</li>
<li>减小容器的体积总是有益的，因为这些镜像会通过互联网拉取与推送。</li>
<li>使用 Docker 进行构建的基本原理是在容器构建的根目录下利用命令安装或编译软件。</li>
<li>执行 <code>run</code> 命令要求所有的可执行文件都包含在容器镜像内。只是在容器镜像中使用 <code>dnf</code> 就需要完整的 Python 栈，即使在应用中从未使用到 Python。</li>
<li><code>ctr=$(buildah from fedora)</code>:<ul>
<li>使用 containers/image 从容器仓库拉取 Fedora 镜像。</li>
<li>返回一个容器 ID （<code>ctr</code>）。</li>
</ul>
</li>
<li><code>mnt=$(buildah mount $ctr)</code>:<ul>
<li>挂载新建的容器镜像（<code>$ctr</code>）.</li>
<li>返回挂载点路径。</li>
<li>现在你可以使用挂载点来写入内容。</li>
</ul>
</li>
<li><code>dnf install httpd –installroot=$mnt</code>:<ul>
<li>你可以使用主机上的命令把内容重定向到容器中，这样你可以把密钥保留在主机而不导入到容器内，同时构建所用的工具也仅仅存在于主机上。</li>
<li>容器内不需要包含 <code>dnf</code> 或者 Python 栈，除非你的应用用到它们。</li>
</ul>
</li>
<li><code>cp foobar $mnt/dir</code>:<ul>
<li>你可以使用任何 bash 中可用的命令来构造镜像。</li>
</ul>
</li>
<li><code>buildah commit $ctr</code>:<ul>
<li>你可以随时创建一个镜像层，镜像的分层由用户而不是工具来决定。</li>
</ul>
</li>
<li><code>buildah config --env container=oci --entrypoint /usr/bin/httpd $ctr</code>:<ul>
<li>Buildah 支持所有 Dockerfile 的命令。</li>
</ul>
</li>
<li><code>buildah run $ctr dnf -y install httpd</code>:<ul>
<li>Buildah 支持 <code>run</code> 命令，但它是在一个锁定的容器内利用 <code>runc</code> 执行命令，而不依赖容器运行时守护进程。</li>
</ul>
</li>
<li>
<p><code>buildah build-using-dockerfile -f Dockerfile .</code>：</p>
<p>我们希望将移植类似 <code>ansible-containers</code> 和 OpenShift S2I 这样的工具，改用 <code>buildah</code> 以去除对容器运行时守护进程的依赖。</p>
<p>使用与生产环境相同的容器运行时构建容器镜像会遇到另一个大问题。为了保证安全性，我们需要把权限限制到支持容器构建与运行所需的最小权限。构建容器比起运行容器往往需要更多额外的权限。举个例子，我们默认允许 <code>mknod</code> 权限，这会允许进程创建设备节点。有些包的安装会尝试创建设备节点，然而在生产环境中的应用几乎都不会这么做。如果默认移除生产环境中容器的 <code>mknod</code> 特权会让系统更为安全。</p>
<p>另一个例子是，容器镜像默认是可读写的，因为安装过程意味着向 <code>/usr</code> 存入软件包。然而在生产环境中，我强烈建议把所有容器设为只读模式，仅仅允许它们写入 tmpfs 或者是挂载了数据卷的目录。通过分离容器的构建与运行环境，我们可以更改这些默认设置，提供一个更为安全的环境。</p>
<ul>
<li>当然，buildah 可以使用 Dockerfile 构建容器镜像。</li>
</ul>
</li>
</ul>
<h3 id="cri-o-kubernetes">CRI-O ：一个 Kubernetes 的运行时抽象</h3>
<p>Kubernetes 添加了<ruby>容器运行时接口<rt>Container Runtime Interface</rt></ruby>（CRI）接口，使 pod 可以在任何运行时上工作。虽然我不是很喜欢在我的系统上运行太多的守护进程，然而我们还是加了一个。我的团队在 <a href="https://twitter.com/mrunalp">Mrunal Patel</a> 的领导下于 2016 年后期开始构建 [CRI-O] 守护进程。这是一个用来运行 OCI 应用程序的 OCI 守护进程。理论上，将来我们能够把 CRI-O 的代码直接并入 kubelet 中从而消除这个多余的守护进程。</p>
<p>不像其它容器运行时，CRI-O 的唯一目的就只是为了满足 Kubernetes 的需求。记得前文描述的 Kubernetes 运行容器的条件。</p>
<p>Kubernetes 传递消息给 kubelet 告知其运行 NGINX 服务器：</p>
<ol>
<li>kubelet 唤醒 CRI-O 并告知它运行 NGINX。</li>
<li>CRI-O 回应 CRI 请求。</li>
<li>CRI-O 在容器仓库查找 OCI 镜像。</li>
<li>CRI-O 使用 containers/image 从仓库拉取镜像到主机。</li>
<li>CRI-O 使用 containers/storage 解压镜像到本地磁盘。</li>
<li>CRI-O 按照 OCI 运行时规范（通常使用 <code>runc</code>）启动容器。如前文所述，Docker 守护进程也同样使用 <code>runc</code> 启动它的容器。</li>
<li>按照需要，kubelet 也可以使用替代的运行时启动容器，例如 Clear Containers <code>runcv</code>。</li>
</ol>
<p>CRI-O 旨在成为稳定的 Kubernetes 运行平台。只有通过完整的 Kubernetes 测试集后，新版本的 CRI-O 才会被推出。所有提交到 <a href="https://github.com/Kubernetes-incubator/cri-o">https://github.com/Kubernetes-incubator/cri-o</a> 的拉取请求都会运行完整的 Kubernetes 测试集。没有通过测试集的拉取请求都不会被接受。CRI-O 是完全开放的，我们已经收到了来自 Intel、SUSE、IBM、Google、Hyper.sh 等公司的代码贡献。即使不是红帽想要的特性，只要通过一定数量维护者的同意，提交给 CRI-O 的补丁就会被接受。</p>
<h3 id="_11">小结</h3>
<p>我希望这份深入的介绍能够帮助你理解 Linux 容器的演化过程。Linux 容器曾经陷入一种各自为营的困境，Docker 建立起了镜像创建的事实标准，简化了容器的使用工具。OCI 则意味着业界在核心镜像格式与运行时方面的合作，这促进了工具在自动化效率、安全性、高可扩展性、易用性方面的创新。容器使我们能够以一种新奇的方式部署软件——无论是运行于主机上的传统应用还是部署在云端的微服务。而在许多方面，这一切还仅仅是个开始。</p>
<p>（题图：<a href="https://www.flickr.com/photos/danramarch/">Daniel Ramirez</a> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>）</p>
<hr />
<p>作者简介：</p>
<p>Daniel J Walsh - Daniel 有将近 30 年的计算机安全领域工作经验。他在 2001 年 8 月加入 Red Hat。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://blog.xu0o0.me/tag/container.html">container</a>
      <a href="http://blog.xu0o0.me/tag/docker.html">docker</a>
      <a href="http://blog.xu0o0.me/tag/linux.html">linux</a>
      <a href="http://blog.xu0o0.me/tag/fan-yi.html">翻译</a>
    </p>
  </div>



<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xu0o0';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
        Please enable JavaScript to view comments.

</noscript>
</article>

    <footer>
<p>
  &copy; xu0o0  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0 International License</a>
</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85250016-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " ~xu0o0 ",
  "url" : "http://blog.xu0o0.me",
  "image": "/img/avatar.jpg",
  "description": ""
}
</script>
</body>
</html>